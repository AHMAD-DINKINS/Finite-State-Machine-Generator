dfa - deterministic finite automaton

define regexin
creating and removing a node
adding transition between nodes
marking state as accepting or rejecting
defining an alphabet


Since this is much more simple, we don't have to be as particular about the grammar that people will use.

//Creating, removing nodes
"Create node '1'"
"Create a node called '1'"
"Remove node '1'"
We can just have keywords "create" and "remove" since they don't seem to serve any other function in DFAs.
Having the name in quotes will help make things easier as well - we can detect the name easier, and the user wil still be able to make nodes with names that use our reserved words.
Essentially, if "create/remove", "node", and something in quotes show up in a sentence, we can assume that they want to make or remove a node of that name.

Do we have to see if they said the word "node"? Would saying "Create '1'" be enough?
I think it would be fine if we have "create" deault to node, and switches to "create transition" if the user has the word transition in the sentence.
We could also ake a convenience function, such as "switch default create to create/transition" so that the user can switch defaults, and doesn't have to type the whole thing repeatedly.

"Make a node called '1'"
"I hate node '1', destroy it"
We can try our hand at creating synonyms for "create" and "remove", and see how it goes. I might just come up with random words when making the official list, and see how it goes.
I'm not sure if going too far with the synonyms will break anything yet.



//Creating an alphabet
"Make the alphabet a set from 'a' to 'z'"
"Generate an alphabet going from '0' to '4'"
If the word "alphabet" is within the line, then we know we are working with the alphabet.
If "create" or any of its equivalents are within the line, we make a new alphabet. Having the word "to" will make it a range between the two values.
Should this delete an already created alphabet and overwrite it?

"Make the alphabet go between '0' and '4'"
The word "between" should also be able to create a range (should it be inclusive or exclusive of the edge values?).

"Make an alphabet of '0', '2', '3', and '4'"
No "to" will just make the alphabet limited to whatever is the input.

"Add '1' to the alphabet"
"Remove '4' from the alphabet"
"Remove the range '1' to '4' from the alphabet"
"Add the range between '1' and '4' to the alphabet"
Having "alphabet" and "add/remove" will add or remove whatever is the input. Can work with a range of value since it has "to"



//Adding transition to the nodes
"create transition 'a' going to 'b' if '0'"
"create transition to 'b' from 'a' if '0'"
Again, use "create" to show you are making something, along with the word "transition". Since there are two items needed to make a transition, people may switch the order.
We might be able to solve this by having a system that detects "to", and sets whatever follows it as the "destination node", and the other node as the "origin node".
How do we distinguish between the origin node and the condition, which is also in quotes?
Use a keyword "if", "when", et cetera, and whatever is the next thing in quotes that follows it will be the condition.

"add transition 'a' to 'b' when '0'"
"make a transition that goes from 'a' to 'b' if the entry is '0'"
Again, an isue with synonyms.
Create => "make", "add", "build", "generate", "produce", and more
Remove => "delete", "destroy", "erase", "discard", "cut out" (I'm pretty sure that two-word keywords won't be an issue)



//Accepting/rejecting state
"Mark nodes '1', '2', '3' as accepting"
"Reject '1'"
"Make the machine accept node '1'"
Having "accept" and "reject", along with a node name (that we check if has already been created, most likely), will mark the node as whatever it's supposed to be.

"Mark node '1' as accepting, and '2' as rejecting"
Technically, this is two statements, so I suppose we could call this illegal in our program ("accept" and "reject" in same sentence) if we are going to be making this thing line-by-line.

"Mark everything other than node '1' as accepting"
Having a node name following the words "except", "other than", etc will make the program inverse select nodes, so this should be fine.

"Reject all nodes"
Since this is a legal move for DFAs, we can make "all" also a keyword that selcts all nodes

I'm not entirely sure what to do with synonyms for "accept" and "reject", since there really aren't many.



//Defining a start position
"Set start to 'a'"
"Start at 'a'"
"Begin at 'a'"
Can have "start" and "begin" (And any other synonyms) mark the beginning position, along with any one node listed in the entry.
We can have the system set so that if the chosen node name was not yet created, the node is automatically created so that people don't have to say "create node" "begin at node"



This was all that came to mind, everything should be covered. All that's left is to actually make the interpreter now.






A DFA is a 5-tuple (Q, E, S, qstart, F), where
–Q is a set consisting finite number of states
–E is an alphabet consisting finite number of characters
–S: Q x E-> Q is the transition function
–qstart is the start state
–F is the set of accepting states
•Note: only 1 start state, and can have many
accepting states

Let M = (Q, E, Since, qstart, F) be a DFA
•Let w = w1 w2 …wn be a string with each wi a member of the alphabet E
•Then, M accepts w if a sequence of states r0, r1, …, rn in Q exists with the three conditions:
–r0 = qstart
–S(ri, w(i+1) = r(i+1)
–rn contained in F